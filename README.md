מבוא

תיאור הפרויקט
פיתוח תוכנה למיון מאגר המיילים. 
התוכנה נועדה להקל בקריאת מיילים רבים בנושאים שונים, כאשר היא מסווגת את המייל לקטגוריה אחרי ניתוח הטקסט, ומציגה למשתמש את התוכן העיקרי של המייל שקשור לאותה קטגוריה. 
התוכנה מתבססת בעיקר על ניתוח והבנת הטקסט, היא מתנהלת באופן דינאמי כך שהמשתמש יכול להוסיף נושאים למיון ולהסיר נושאים לא רצויים, ולצורך כך התוכנה הינה תוכנה מתלמדת.

הרקע לפרויקט
בשעות הרבות בהן עמלתי לבחור רעיון, עלו במוחי עשרות אפשרויות. חלקן מוכרות וקימות וחלקן דלות אלגוריתם, תרתי אחר רעיון שימצה את הידע והלמידה הרבה שקניתי במהלך שנות הלימוד והוצאת התעודה.
מטרתו העיקרית של פרויקט הגמר היא התלמדות, הכרת אלגוריתמים, התנסות עצמית וכמובן שלב הפיתוח עצמו, ואכן מטרת ההתלמדות ורכישת הידע הייתה מטרה משמעות בפרויקט. 
קריטריונים נוספים שעמדו בפני הם- להגיע לרעיון אתגרי ומעניין שיהווה פריצת דרך ויהיה שימושי וכמובן ימומש באלגוריתם חזק וחכם שייתן מענה יעיל לפיתוח נכון.
בחרתי את תחום חקר השפה- בפיענוח מלל ,הבנתה ואופן הפעילות בעקבות כך.
כיום כאשר עולם הטכנולוגיה הולך ומתפתח, אחת הדרכים הנוחות והמקובלות של לקוחות
לתקשר עם מוסד או ארגון היא בעזרת תיבת המייל, כתוצאה מכך תיבת המיילים של כל
מוסד או ארגון מתמלאת באופן מהיר ביותר בהודעות המחכות לקבל מענה. בסופו של
דבר תיבת המייל מכילה בערבוביה מיילים רבים מסוגים שונים, ומנושאים מגוונים שכל
אחד מהם דורש טיפול/ התייחסות אחרת שאינה דומה לרעהו .
על מנת לתת מענה ויחס לכל המיילים שהתקבלו, ולהתייחס אל כל אחד לפי הסוג והנושא
שלו, דרוש כוח אדם, סבלנות רבה, זמן וכושר ריכוז מקסימלי לעבור מנושא לנושא ומעניין
לעניין של כל מייל.
על מנת לסייע בכל אלו החלטתי לייצר כלי עזר לתיבת המייל שימיין את המיילים לנושאים
ולקטגוריות שונות ובכך לצמצם ולהפחית את השימוש בכוח אדם העוסקים במלאכה הקשה.

תהליך המחקר
לפני כשנה פנה אלי מזכיר של ארגון מסוים באלעד ושאל אותי אם אני מכירה כלי שימיין 
בשבילו את תיבת המיילים של הארגון שמתמלאת בקצב מהיר ומסחרר, ערכתי הרבה מאוד חיפושים באינטרנט ולא מצאתי שקיים כלי/תוסף למיון תיבת המייל שניתן להגדירו במהירות ובנוחות.
ב-outlook  וב-Gmail  כן ישנה אפשרות לחלק את תיבת המייל הנכנס לקטגוריות, אבל זה עובד שהמשתמש צריך להכניס תחילה כללים מדויקים לסיווג, לדוגמא כל המיילים שהגיעו מנמענים מסוימים להכניסם לתיקייה כלשהיא, וכן כל המיילים שהגיעו עם כותרת "...." -להכניסם לתיקיה אחרת, כלומר המערכת לא לומדת או מסיקה מסקנות מעצמה לפי בחירות של המשתמש או מילות מפתח שחזרו על עצמם בכל הקטגוריה, אלא צריך להגדיר לה במדויק עבור אילו מילים או מוענים היא תשייך את המייל הספציפי לקטגוריה הרצויה- מה שיוצר סרבול וקושי למשתמש וקושי לחזות את תוכן המיילים שיגיעו.
לאחר זמן הרגשתי שהתחברתי לנושא והחלטתי לבנות תוכנה שתפתור היא בעצמה את הבעיה, בתחילת הדרך חשבתי לבנות את המערכת שתעבוד רק לארגון מסוים אך לבסוף החלטתי לבנות אותה בצורה גלובלית ולא ספציפית כדי שתוכל להתאים לחברות נוספות.
פיתוח מערכת חדשה זו תאפשר למשתמש לצפות במיילים הממוינים עפ"י קטגוריות אותם
הגדיר קודם לכן או תוך כדי השימוש, כך שהמערכת פועלת באופן דינאמי, לומדת ומסיקה מסקנות לאורך כל חיי תפקודה עמ' לספק למשתמש יעילות, אמינות ונוחות.

סקירת ספרות
•	ויקיפדיה 
•	Stack overflow
•	Hebrew Nlp
•	Microsoft
•	Email-Js

אתגרים מרכזיים
הבעיה המרכזית בפרויקט היא סיווג המיילים לקטגוריות, כלומר לגרום למערכת "להבין" את תוכן המייל ולסווגו לקטגוריה הנכונה.
בנוסף רציתי ליצור מצב בו המשתמש יכול לשנות את את החלטת האלגוריתם- את נושא המייל, והמערכת תסיק מסקנות לגבי פעולה זו.
כמו כן רציתי שבכל שלב של המערכת, למשתמש תהיה אופציה להוסיף ולהסיר נושאים והמערכת תתמוך במהלכים אלו מבחינה לוגית, ותיקח בחשבון נושאים "ירוקים" לעומת ותיקים מהם.
עוד אתגר שהיה לפני הוא ההתחברות לתיבת המייל ותפיסת כל מייל שמגיע לתיבה.

יעדים ומטרות
היעד שהצבתי לפני היה:
לסווג את המיילים באופן מיטבי ומהיר, בעזרת אלגוריתם יעיל ככל האפשר, הן מבחינת אופטימליות ונכונות הסיווג והן מבחינת סיבוכיות זמן הריצה, בכדי-
•	לחסוך במשאבים ובכוח אדם.
•	לספק נוחות למשתמש ולתת אפשרויות שונות של הצגה וסינון ושימוש במידע.
המטרה שלי דרכו:
רכישת ידע והכרה היקפית בטכנולוגית ריאקט שמזנקת ברמת ההתפשטות בשנים האחרונות 
ועוד. data-bases הכרת , Entity Framework ,Web Api   ובטכנולוגיות נוספות כגון:
ולכן התחלתי עם בניית מנגנון נכון ויעיל של ניתוח הטקסט המתקבל תוך תכנון מעמיק והגדרת הדרישות ויצירת ממשק שיאפשר למשתמש לצפות בנתונים בצורה גמישה ונעימה לעין.

אתגרים
כאשר התחלתי לכתוב את הפרויקט ניצבו בפני כמה אתגרים:
•	החומרים ברשת בשפה העברית מוגבלים.
•	להשיג ספריה שמנתחת את השפה העברית וללמוד איך להשתמש בספריה זו.
•	ברגע שאני נותנת למשתמש אפשרות להוספת קטגוריות לסיווג בעצמו צריך לשים לב 
לקטגוריות הצעירות שאין עליהם מספיק מידע כדי לקבוע את הסיווג.
•	יש לשים לב ללקיחת מסקנות משינוי נושא המייל ע"י המשתמש.
•	חשובה לי אסטטיות, כך שגם צד הלקוח דרש את שעותיו הרבות..

מדדי הצלחה
בדיקה האם הפרויקט עונה על ההגדרות נעשית ע"י שליחת מיילים לתיבת המייל של הפרויקט והרצת האלגוריתם של הפרויקט תוך ווידוי שהאלגוריתם אכן מסווג את המיילים לקטגוריות באופן מהיר ועד 80% נכונות. 
במקרה של טעות המשתמש יכול לשנות את נושא המייל כהבנתו, ניתן לבדוק את המערכת שוב ולראות את המסקנות שהמערכת לקחה מפעולה זו.
רקע תיאורטי
עיבוד שפה טבעית )באנגלית (NLP -Natural Language Processing :הוא תת-תחום של אינטליגנציה מלאכותית ובלשנות . הוא חוקר את הבעיות הקשורות לעיבוד ומניפולציה של שפה טבעית , והבנה של שפה טבעית על מנת לגרום למחשבים " להבין" דברים שנאמרים או נכתבים בשפות אנושיות . עיבוד השפה הטבעית קשור לתחום הבלשנות החישובית , ולעיתים משתמשים במונחים אלה ללא הבחנה ביניהם. 
כאן, נתייחס לעיבוד שפה טבעית כתחום המעשי של פיתוח יישומי מחשב המטפלים בשפה אנושית. 
הערך " בלשנות חישובית " עוסק בפן התאורטי של שילוב רעיונות מתחום מדעי המחשב בחקר השפה האנושית.
מערכת לומדת היא מערכת אשר משפרת את ביצועיה בביצוע משימה נתונה ככל שהיא מבצעת משימה זו.
עקרון הפעולה של מערכות אלו בנוי משני שלבים עיקריים, למידת המידע ובדיקת מידע חדש
בשלב הלמידה, הידוע גם כשלב אימון המערכת, המערכת מקבלת מידע מוכר ובונה מודל סטטיסטי באמצעותו תאפיין מידע חדש בשלב הבדיקה, 
המערכת מקבלת מידע חדש ובהתאם למודל שנבנה מסווגת אותו.
אופן פעילות התוכנה מתחלק מאחורי הקלעים לשני חלקים:
בתחילה השימוש אין למערכת מספיק נתונים על סיווגים מוצלחים שיסייעו לה לפענח את המייל. בשלב זה כשמגיע מייל חדש המערכת מנסה לסווג אותו כפי יכולתה אך תפקיד המשתמש הוא לעקוב אחרי התוצאות ובמידת הצורך גם לתקן את הנושא הנבחר כדי לשפר את האלגוריתם, המערכת מסיקה מסקנות אודות הסיווגים, ולומדת על פיהם כיצד לסווג את
הבאים אודות לכך שהיא מערכת מתלמדת.
בשלב הבא- שלב התפעול, המערכת תהיה מסוגלת לסווג את המיילים בכוחות עצמה עפ"י הידע שרכשה קודם בשלב -הלמידה, בשלב זה היא ממשיכה להגדיל את מאגרי המידע ע"י כל סיווג וסיווג, ובמקרה שטעתה בהחלטתה גם כאן המשתמש יוכל להתערב ולשנות את הקטגוריה.
שני השלבים המתוארים יקרו ויחזרו על עצמם בכל פעם שתוכנס למערכת קטגוריה חדשה.

תיאור מצב קיים
כיום כאשר עסק או ארגון רוצים לקבל מייל בצורה ממוינת הם יכולים להשתמש במוצרים:
OUTLOOK:
התוכנה מאפשרת למשתמש לחלק את תיבת המייל לקטגוריות שונות כדוגמא- 
כל המיילים שהגיעו מנמענים מסוימים להכניסם לתיקייה כלשהיא, וכן כל המיילים שהגיעו עם כותרת "...." -להכניסם לתיקיה אחרת. עמ' שהמערכת תדע להכניס כל מייל לתיקייה המתאימה נדרש מהמשתמש להזין מס' כללים בצורה שאינה נוחה וברורה למשתמש כמו"כ המערכת אינה פועלת באופן דינאמי ומתלמד, אלא פועלת עפ"י הכללים אותם הזין המשתמש תחילה.
GMAIL:  
ניתנת למשתמש אפשרות להגדיר תוויות עם שמות נושאים, המשתמש יכול לבחור
קריטריונים לסינון, למשל, הודעות מכתובת אימייל מסוימת או עם מילים מסוימות בשורת הנושא או בגוף המייל עצמו. 
גם פה בדומה לOUTLOOK המערכת לא לומדת מעצמה או מסיקה מסקנות, אלא צריך להגדיר לה במדויק עבור אילו מילים/מוענים היא תשייך את המייל הספציפי לקטגוריה הרצויה- מה שיוצר סרבול וקושי למשתמש.
ניתן גם לתת את העבודה של המיון למזכירה, אך בחלופה זו ישנם כמה חסרונות כמו:
•	כסף
•	מידור- כלי זה יכול גם לשמש ארגונים בהם קיימים מספר עובדים או מזכירים שכל אחד מהם מתעסק בתחום אחר וחסוי מאחרים, הכלי יכול לשמש אותם במיון המיילים הממוענים לתחום נפרד וספציפי, כך שכל אחד רואה ומתעסק במיילים המיועדים אליו בלבד ולא נחשף לתחומים האחרים, ולכן במקרה כזה שהנושאים רגישים או סודיים אין עדיפות לעין אנושית.
•	בזבוז זמן- עד שהמזכירה האחראית על הסיווג מאשרת את הקטגוריה, המייל לא יגיע לעובד האחראי על אותה קטגוריה, ויכול להתפספס זמן יקר, ולכן חלופה זו כמובן אינה עדיפה על סיווג אוטומטי.

ניתוח חלופות מערכתי
במצב כזה שהמשתמש בוחר את הקטגוריה בעצמו זה דרושה סבלנות רבה, זמן וכושר ריכוז מקסימלי לעבור מנושא לנושא ומעניין לעניין של כל מייל.
דרכי הפתרון שנבדקו היו רבות, כמובן שרעיון של סיווג ידני ע"י כח אדם ירד מיד כי מטרת הפרויקט היא לצמצם ככל הניתן בעבודה ידנית.
בין החיפושים אחר אלגוריתם מתאים נתקלתי באלגוריתם של סיווג עפ"י "מבחן כי בריבוע לבדיקת השערת אי תלות", לאחר שלמדתי את הנושא לעומקו הבנתי שמבחן זה לא מתאים לי לסיווג, מכיוון שהוא בודק האם ישנה שייכות או אינה קיימת שייכות בין כל הקטגוריות והמילים ולא פר קטגוריה וקטגוריה.
למעשה לאחר שקראתי רבות על אלגוריתם זה הבנתי שהוא כן יכול לעזור לי בנושא ספציפי אחר של האלגוריתם ואכן השתמשתי בו (יורחב בהמשך) 
עוד אלגוריתם שנבדק הינו אלגוריתם "סיווג בייסאני נאיבי", ויקיפדיה:
''' סיווג בייסיאני נאיבי (או סיווג נאיב בייס - Naive Bayes classifier) בלמידת מכונה הוא אוסף שיטות סיווג המבוססות על חוק בייס‎ ועל ההנחה ה"נאיבית" שאין תלות בין תכונות האובייקטים המסווגים כאשר כבר ידוע סיווגם...
באופן כללי סיווג בייסיאני נאיבי מניח שאם כבר ידוע הסיווג אז ערכי התכונות בלתי תלויים עוד זה בזה. הנחה זאת היא כמובן אולי לא מדויקת, ולכן ערכי ההסתברויות הנובעים ממנה והמשמשים את הסיווג הינם אולי לא מדויקים... '''
אלגוריתם זה משמש גם לסיווג טקסט, ויקיפדיה:
''' סיווג בייסיאני נאיבי הניב תוצאות יפות בתחום של סיווג טקסט לקטגוריות - כמו למשל סיווג דואר אלקטרוני ל"ספאם" או "לא-ספאם", על סמך המילים הכלולות בטקסט... '''
לאחר קריאה מעמיקה ועיון באלגוריתם ואף התחלת כתיבת הקוד שלו הבנתי שאף הוא אינו מתאים לי, מכיון שאני רוצה שהמערכת תתמוך בקטגוריות שתהינה קשורות אחת לשנייה בקשרי אבא לבן- מה שסותר את ההנחה הנאיבית לאי תלות בין תכונות המילים של הקטגוריות.
לאחר חשיבה החלטתי ליצור אלגוריתם משל עצמי שיתמוך בצרכי המערכת, האלגוריתם מבוסס בעיקרו על רעיון שקראתי באינטרנט ונתן לי השראה לעיצובו (N-gram model).
האלגוריתם שיצרתי עונה על כל הדרישות הנדרשות, מביא תוצאה הכי קרובה ובזמן ריצה הגיוני. 

תיאור החלופה הנבחרת והנימוקים לבחירתה
מכיוון שלא קיים רעיון חדשני כזה בשוק לכן יש צורך לפתח תוכנה חדשה שתסווג את המיילים בצורה אוטומטית ע"י אלגוריתם למידת מכונה.
חלופה זו היא הטובה ביותר וחוסכת בכוח אדם, כאב ראש ועלויות.











אפיון המערכת

ניתוח דרישות המערכת
סביבת פיתוח:
חומרה: מעבד i5 ram 8GB 
עמדת פיתוח: מחשב  lenovo
מערכת הפעלה: Windows 10
שפות תוכנה: ,c# תוך שימוש בטכנולוגיות  webApi ,react ts
כלי תוכנה לפיתוח המערכת: Visual Studio Code,  Microsoft Visual Stidio ,Postman
מסד נתונים: Sql Server
עמדת משתמש מינימלית:
חומרה Core i5 or higher :
מערכת הפעלה: Windows 10
תוכנות: visual s tudio
חיבור לאינטרנט: נדרש

מודול המערכת
נושאים באחריות המערכת:
   •   המערכת תופסת את המייל בעת כניסתו לתיבת המיילים של המשתמש ומנתחת אותו.
•      על פי הניתוח המערכת מסווגת את המייל לקטגוריה המתאימה ומוצאת במייל את   
        המשפט שמסמל הכי את הנושא.
•      המערכת תומכת בהכנסת/מחיקת קטגוריות בעזרת האתר.
 •     המערכת תדאג להצגת המיילים המסווגים בצורה מסודרת ונוחה למשתמש.
נושאים שבשלב פיתוח זה אינם באחריות המערכת:
  •  המערכת תומכת במיילים הרשומים בשפה העברית לבד, מילה מלל בשפה זרה אינו נלקח 
      בחשבון של האלגוריתם.
•    אין מעקב אחרי שגיאות טקסט/ שגיאות לשון.
  •  המערכת כרגע אינה מתעסקת עם שרתי מיילים ועובדת על החשבון המייל המקומי בלבד.
•    המערכת אינה באה להחליף את הפלטפורמות של תיבות המייל הקיימות בשוק אלא  
     להשתלב בהם (תוסף), אי לכך המערכת לא מכילה פונקציות לטיפול במיילים, כמו   
     שליחת מייל, מחיקת מייל וכדומה.
•    המערכת מסווגת את המיילים בצורה תקינה עד לנכונות של עד 80% מהפעמים.
אפיון פונקציונלי
•      כניסת משתמש דרך כתובת מייל וסיסמא.
•      קבלת מייל לתיבה.
 •     מציאת הנושא בו המייל עוסק והכנסתו לקטגוריה המתאימה.
•      מציאת המשפט המסמל הקטגוריה הנבחרת.
•      נתינת אפשרות למשתמש לשנות את החלטת המערכת ולקיחת מסקנות מהפעולה.
•      המשתמש יוכל להוסיף עוד קטגוריות תוך כדי השימוש והמערכת תתארגן בהתאם.

ביצועים עיקריים
החלק המרכזי במערכת הינו סיווג המייל לאחת מבין הקטגוריות הקיימות.
התוכנה עושה זאת על סמך סיווג מוצלח של המיילים הקודמים (באם מילים מסוימות הופיעו בקטגוריה מסוימת יותר מקטגוריה אחרת יש סיכוי סביר שגם הפעם המייל שייך לקטגוריה זו) וממסקנות שלקחה תוך כדי ריצה על פי תיקונים ידניים שיבצעו המשתמשים.

אילוצים
מגבלות המערכת הנן נובעות מעצם היותה מערכת ולא מח אנושי, וכחלק מכך יתכנו טעויות שיכלו להימנע אם עין אדם אנושי הייתה עוברת על תוכן המייל.
ובנוסף האלגוריתם שתופס את המייל החדש ומנתח את תוכנו מוכרח להתרחש תוך כמה שניות מזמן קבלת המייל, משום שכאשר יכנסו כמה מיילים בשנייה לעיתים נוצר "אפקט השירה" ונאלצים להמתין זמן רב יותר לקבלת כל המיילים.











תיאור הארכיטקטורה


הארכיטקטורה של הפתרון המוצע
צד שרת מחולק כמקובל לשכבות: 
•      שכבת ה-DAL  
•      שכבת ה-DTO  
•      שכבת ה- BLL 
•      שכבת ה-WebApi  




החלוקה לשכבות נועדה להפריד באופן מוחלט בין הלוגיקה של הפרויקט לבין הנתונים עצמם, ומלבד היתרונות הרגילים בתוכנה מודולרית בעלת ממשקים מוגדרים היטב, ארכיטקטורת שלוש השכבות מאפשרת גם החלפה או שדרוג של כל אחת מהשכבות באופן בלתי תלוי וללא זעזועים בשכבות האחרות, בהתאם לדרישות או לשינויים בטכנולוגיה, ונוחה לאיתור באגים.
פירוט הרכיבים:




:DAL 
שכבת ה Dal –היא השכבת דרכה ניגשים לנתונים היושבים ב DB -היא מכילה מחלקות המייצגות את בסיס הנתונים. 
פעולות ההתקשרות עם בסיס הנתונים נעשו בטכנולוגיות entity framework .טכנולוגיה זו היא המקובלת לטיפול בבסיס הנתונים כאשר היא מנתחת את בסיס הנתונים, בונה מחלקות לייצוג הטבלאות ומאפשרת לעבוד עם הנתונים באמצעות אובייקטים של מחלקות ספציפיות בלי להתמקד בטבלאות ובעמודות המשמשות בסיס למסד הנתונים, כך אפשר לעבוד באופן אבסטרקטי ולתחזק את היישום באופן מונחה עצמים. 
BLL:

בשכבה זו כתובה הלוגיקה של הפרויקט, ובה יופיע אלגוריתם ניתוח המייל. 

DTO:

שכבה זו מכילה מחלקות המקבילות לטבלאות במסד הנתונים וכן פונקציות המרה הממירות 
אובייקטים מטיפוס הנתונים של מסד הנתונים לטיפוס של המחלקה המקבילה בDTO ולהיפך, ומטרתה לספק מבנה נתונים -אחיד לשימוש שתי השכבות DAL ו BLL- ללא תלות בבסיס הנתונים.
Web api:

מתודות השרת המחצינות את הפעולות שניתן לבצע בשרת. מתודות אלו משתמשות ב- BLL ומופעלות ע"י שכבת ה Gui -בצד לקוח.

תיאור הרכיבים בפתרון
הפרויקט פותח בסביבת עבודה NET בשיתוף טכנולוגיית WebApi המאפשרים בניית אתר של 
צד שרת–לקוח בצורה מובנת וברורה.
צד השרת נכתב בשפת C# בשימוש טכנולוגית Entity Framework הפונקציות בו יבצעו את ניתוח המייל תוך חלוקה נכונה ומסודרת של הקוד .
האתר – צד הלקוח נבנה בפלטפורמת react נכתב ב -HTML ו Typescript-בתוספת ספריות
 material-ui, Bootstrapונעזר בפונקציות רבות לצורך יצירת חווית משתמש גבוהה הן מצד מהירות השירות והן מצד נוחות המשתמש .
מסד הנתונים הוא Sql server ומשתמש בשאילתות SQL .
באופן כללי הושקעה מחשבה רבה הן ביצירת האתר שיהיה נח וקל לתפעול והן בכתיבת הקוד שיהיה מהיר ויעיל ככל האפשר.

פרוטוקול התקשורת
פרוטוקול התקשורת הינו .HTTP 

שרת-לקוח
הטכנולוגיה המקשרת בין השרת ללקוח היא בשכבת ה Web Api שמגדירה קונטרולרים השולפים / מעדכנים / מוחקים נתונים מהשרת ללקוח וכן להיפך.

מבני הנתונים
•	Dictionary – עבור אחסון והעברת נתונים תוך כדי אלגוריתם הניתוח.
•	List - עבור אחסון והעברת נתונים תוך כדי אלגוריתם הניתוח.
•	Tree – 
1.	אלגוריתם של ניתוח המייל בונה יער של עצים המייצגים את הנושאים של המשתמש לפי קשרי אב ובן, עץ זה משמש את האלגוריתם בהכרעתו.

2.	כל 20 מיילים המערכת מעדכנת את המילים שבמאגר, בשביל זה היא ממירה עץ כללי לעץ בינארי שייצג את הנושאים לפי העיקרון שהבנים נמצאים בצד השמאלי והאחים בצד הימני.

הקשרים בין היחידות השונות בפרויקט
הקשר בין יחידות המחלקה השונות הינו ע"י הכלה (עצם כמאפיין במחלקה) או שהקשר זר לחלוטין, אין יחסי ירושה בפרויקט, למען עצם אובייקט ומספר בודד של עצמים.
הפרויקט מורכב מ -3 שכבות עיקריות, כל יחידה מכירה את השכבה שמעליה :
•	יחידת בסיס הנתונים: מבנה הנתונים.
•	יחידת האלגוריתם: הקוד והתכנון, ע"מ לגשת מפרויקט זה למסד הנתונים יצרתי מחלקה המטפלת בכך  ClassDB, מחלקה זו מכילה עצם מסוג המודל וכך היא יכולה לגשת לנתונים, היא מכילה גם עצם של פרויקט Dto ע"מ להמיר את הנתונים מסוג Dto לסוג Dal.
•	יחידת ממשק המשתמש: צד ה GUI הלוגי, ממשק המשתמש מעוניין לגשת לפעולות של הכנסה למסד הנתונים ולפעולות שמבצע האלגוריתם המרכזי ולכן יצרתי מופעים של המחלקות המטפלות בנתונים ושל המחלקה שאחראית על האלגוריתם המרכזי וכך ניתן לגשת לפעולות שלהם.

תיכון מפורט
השתמשתי בטכנולוגית API שהיא ערכה של ספריות קוד, פקודות, פונקציות ופרוצדורות מן המוכן, בהן יכולים המתכנתים לעשות שימוש פשוט, בלי להידרש לכתוב אותן בעצמם כדי שיוכלו להשתמש במידע של היישום שממנו הם רוצים להשתמש לטובת היישום שלהם.

חלופות לתיכון המערכת
יכולתי להשתמש בטכנולוגית MVC אבל יש לה כמה חסרונות מול API:
1.	MVC  Net. Asp משמש ליצירת יישומי אינטרנט שמחזירים תצוגות ונתונים, אך .Net Asp API Web משמש ליצירת שירותי HTTP מלאים בצורה קלה ופשוטה המחזירה נתונים בלבד ולא תצוגה.
2.	API Web עוזר לבנות שירותי REST מלאים על פני Framework NET. והוא תומך גם במשא ומתן על תוכן) זו החלטה על נתוני פורמט התגובה הטובים ביותר שיכולים להיות מקובלים על ידי הלקוח. זה יכול להיות ATOM, XML, JSON או נתונים מעוצבים אחרים ,( אירוח עצמי) שאינו ב MVC.


3.	API Web דואג גם להחזיר נתונים בפורמט מסוים כמו XML, JSON או כל דבר אחר המבוסס על כותרת קבל בבקשה ואתה לא דואג לזה MVC. מחזיר נתונים רק בפורמט JSON באמצעות JsonResult. 
4.	ב API Web- הבקשה ממופה לפעולות המבוססות על פעלים ב HTTP- אך ב MVC-היא ממופה לשם הפעולות.
5.	API Web Net.Asp הוא מסגרת חדשה וחלק ממסגרת הליבה של NET.ASP . כריכת המודל, המסננים, הניתוב ותכונות אחרות של MVC קיימות ב API Web- שונות מ MVC- וקיימות במכלול Http.Web.System החדש. ב ,MVC- תכונות אלה קיימות בתוך Mvc.Web.System. מכאן שניתן להשתמש ב API Web- גם עם Net.Asp וכשכבת שירות עצמאית.
6.	אתה יכול לערבב API Web ובקר MVC בפרויקט אחד לטיפול בקשות AJAX מתקדמות שעשויות להחזיר נתונים בתבנית XML, JSON או בכל אחרים ולבנות שירות HTTP מלא. בדרך כלל זה ייקרא אירוח עצמי של.API Web
7.	יתר על כן, API Web הוא ארכיטקטורה קלילה, פרט ליישום האינטרנט, ניתן להשתמש בו גם עם אפליקציות לסמארטפונים.














תיאור התוכנה

סביבת עבודה
•	Microsoft visual studio 19
•	Microsoft visual studio code
•	Sql server management studio 19

שפות תכנות
•	C#
•	Sql
•	Html , css, ts בטכנולוגית react

תיאור מסכים   
•	כניסה, התחברות המשתמש למערכת.
•	הצגת מיילים
•	הצגת מיילים לפי קטגוריות
•	הצגת הקטגוריות של המשתמש + הוספת קטגוריה חדשה.
•	אודות המערכת ומדריך למשתמש


תיאור המחלקות המוצעות
שכבת DataBase:                                                                                                            שכבה זו היא בסיס הנתונים בה נשמרים הנתונים עבור הפרויקט. שכבה זו בנויה כקובץ של DataBase SQL ומכילה את כל הטבלאות הנחוצות עבור דרישות המערכת.
שכבת dal:                                                                                                              שכבה שממפה את כל הטבלאות במסד נתונים למחלקות בC# .                                      (לא נפרט כעת כל מחלקה משני השכבות הנ"ל כי כל מחלקה זו היא טבלה במסד נתונים וזאת נפרט בהמשך)
שכבת dto:                                                                                                                       שכבת קישור בין מחלקות ה dalלבין המחלקות שצריכות לחזור למשתמש.                העצמים מסוג dto הן העצמים שחוזרים למשתמש, ולכן בכל אחת מהמחלקות יש את המאפיינים המבוקשים שנוצרו אוטומטית במחלקה התואמת בDal, העצמים הם שטוחים ללא הכלה בין המחלקות כדי שהנתונים יוכלו לחזור למשתמש . וכן יש פונקציית המרה מעצם המקביל בDal  לעצם מסוג dto ופונקציית המרה מעצם מסוג dto לעצם מקביל בDal, לכן הקלט הוא עצם מסוג שרוצים להמיר ממנו, והפלט הוא העצם המומר לסוג שרצו. (המחלקות תואמות למחלקות הdal ולכן גם אותם לא נפרט)
שכבת bll:                                                                                                                  זוהי שכבת הקוד בה כתובה כל הלוגיקה של הפרויקט. שכבה זו מתאמת את פעולות היישום, מעבדת פקודות, מבצעת החלטות והערכות לוגיות, חישובים ואלגוריתמים שונים. השכבה מעבירה ומעבדת את הנתונים בין שתי השכבות המקיפות אותה web-api  ו- dal.
פירוט המחלקות בשכבה זו:

מחלקת ClassDB –
תפקיד המחלקה: מחלקה המאגדת את כל פונקציות הגישה לבסיס הנתונים.
קלט: מקבלת פרמטרים מהמשתמש ומהאלגוריתם איתם היא מעדכנת את הדאטה כנדרש.
פלט: נתונים מהמסד נתונים או תוצאות לאחר עיבוד נתוני בסיס הנתונים.
פונקציות המחלקה: פו' המבצעות הוספה, עדכון, מחיקה ושליפה מהמסד נתונים.

מחלקת OutlookConnecting -
תפקיד המחלקה: אחראית על ההתחברות לתיבת המייל וכן על אירוע תפיסת המייל.
קלט: מייל חדש שנכנס למערכת.
פלט: אין.
פונקציות המחלקה: 
public void StartConection() – פונקצית התחברות לתיבת המייל של המשתמש.
- מופעלת אוטומטית בכל הגעת מייל חדש. public void RecivedMail(object Item)

מחלקת BuildWordsStruct:
תפקיד המחלקה: אחראית על ניתוח תוכן המייל ובניית מבנים להמשך האלגוריתם.
קלט: מייל חדש.
פלט: מבנים המסמלים את הניתוח, ובמהלך האלגוריתם- האלגוריתם ישתמש בנתונים אלו.
פונקציות המחלקה: 

public class BuildWordsStruct
פונקציה הבונה את האובייקט ואחראית על השמת המבנים.

public List<string> CleanWords(string title, string body)
פונקציה המקבלת כותרת וגוף מייל ומחזירה רשימה של מילים "נקיות" לניתוח

private void AddWeight(int wordId, string word, List<WordForSubjectDto> wordsForSubject)
פונקציה המקבלת מילה ורשימת כל הקשירויות שלה עם כל הנושאים ומוסיפה במבנה-במקום של הנושאים משקל לפי הקשירות.

private void AddWeightForSimilar(string baseWord, Dictionary<string, double> words, Dictionary<int, List<WordForSubjectDto>> allWordsForSubjects)
פונקציה המקבלת מילה ואת רשימת המילים הנרדפות לה ורשימה המכילה את כל הקשירויות בין המילים לנושאים, ומוצאת את כל הנושאים שצריך להוסיף להם משקל בגללה.

מחלקת FindSubject:
תפקיד המחלקה: אחראית על מציאת נושא המייל בהתבסס על ניתוחו.
קלט: מבנים המייצגים את ניתוח המייל.
פלט: נושא המייל.
פונקציות המחלקה:
public static int FindMailSubject(int user, Dictionary<int, int> subjectWordsAmount, Dictionary<int, FindNode> searchTree, Dictionary<int, double?> contactmanWeight)
הפונקציה הראשית שמקבלת את המבנים, היא קוראת לשאר הפונקציות שבמחלקה.

private static int FindTreeRoot()
פונקציה המוצאת את תת העץ המקסימלי שממנו יתחיל החיפוש לכל הצאצאים שמתחתיו.

private static (int maxSub, double maxMark) FindMaxNode(List<int> nodes)
פונקציה המקבלת רשימת נושאים ומוצאת את הנושא המקסימלי מבינהם.
private static int FindSubectByTree(int parentSub)
פונקציה רקורסיבית לגילוי הנושא המקסימלי מתת עץ.

מחלקת FindRelatedSentence:
תפקיד המחלקה: אחראית על מציאת משפט קשור לנושא הנבחר.
קלט: מבנים המייצגים את ניתוח המייל.
פלט: משפט שהכי קשור לנושא מבין המשפטים של המייל.
פונקציות המחלקה:
public static string FindMailKeySentence(string emailContent, int subjectId, Dictionary<int, Dictionary<string, BuildStructs.WordForSub>> MarksWordsForSub, Dictionary<int, Dictionary<string, BuildStructs.semilarWordForSub>> MarksSemilarsForSub)
הפונקציה הראשית שמקבלת את המבנים ומוצאת את המשפט.

public static string FindKeySentenceForUpdateSubject(EmailDto email, int newSubjectId)
פונקציה שאחראית על בניית מבנים מנתונים בדאטה בייס כדי לשלוח אותם לפונקציה של מציאת המשפט, זה קורה כאשר משתמש משנה את הקטגוריה של המייל לאחר החלטת האלגוריתם

מחלקת HebrewNlp:
תפקיד המחלקה: אחראית על חיבור לספרית HebrewNlp ושימוש בה.
קלט: מילים או רשימות מילים או טקסטים לצורך ניתוח.
פלט: החזרת הקלט בצורה מנותחת.
פונקציות המחלקה:
public static List<string> NlpForWords(List<string> words)
פונקציה המקבלת רשימה של מילים ומחזירה רשימה של מילות הבסיס שלהן

public static Dictionary<string, double> NlpForSimilarWords(Dictionary<string, double> words)
פונקציה המקבלת מילון של מילים נרדפות ומחזירה מילון עם מילות הבסיס שלהן

public static string NlpSingleWord(string word)
מקבלת מילה ושולחת אותה לפונקציה שמחזירה מילת בסיס, הפונקציה מסננת אפשרויות.

public static HebrewNLP.Morphology.MorphInfo AnalyzeWord(string word)
הפונקציה מקבלת מילה, מתחברת לספרייה ומחזירה את מילת הבסיס שלה.

public static List<string> SpliteToSentences(string words)
מקבלת טקסט, מתחברת לספריה ומחזירה רשימה של משפטים מהטקסט.

מחלקת Synonyms:
תפקיד המחלקה: אחראית על מציאת מילים נרדפות.
קלט: מילה מתוך מייל.
פלט: מילים נרדפות לאותה מילה כולל אחוז דמיון.
פונקציות המחלקה:
public static Dictionary<string, double> GetSimilarWords(string word)
מקבלת מילה ומחזירה מילון המכיל מילים נרדפות ואחוז דמיון לאותה מילה.

מחלקת UpdateInDB:
תפקיד המחלקה: אחראית על עדכון והשמה בדאטה לאחר האלגוריתם.
קלט: מייל ומבנים שמסמלים את הניתוח.
פלט: המסד נתונים מתעדכן.
פונקציות המחלקה:
public static void UpdateEmail(EmailDto email, BuildWordsStruct buildWordsStruct)
פונקציה המקבלת מייל ומבנים המסמלים את ניתוחו ומעדכנת בדאטה את מה שצריך לעדכן

מחלקת UpdateCommonWords:
תפקיד המחלקה: אחראית על עדכון מילים משותפות.
קלט: קוד משתמש.
פלט: עדכון מילים כ"מילים משותפות".
פונקציות המחלקה:
public static void UpdateLevelWord(int userId)
הפונקציה הראשית, קוראת לשאר הפונקציות שבמחלקה.

public static BinaryTree BuildTree(Dictionary<int, int?> subDic)
פונקציה שמקבלת את נושאי המשתמש ובונה מהם עץ בינארי.

public static BinaryNode GetParentNode(BinaryNode tree, BinaryNode node)
פונקציה המקבלת שורש עץ וצומת ומחזירה את האבא של הצומת שנשלחה

public static void UpdateJointWord(BinaryNode n, Dictionary<int, Statistic> dicStatistic, int idWord)
פונקציה המקבלת את עץ הנושאים ורשימות סטטיסטיות ומילה, ובודקת האם המילה משותפת, ולפי זה היא מעלה אותה ברמות בעץ.

מחלקת ChiSquare:
תפקיד המחלקה: מחלקה סטטיסטית לבדיקת תלות בין משתנים.
קלט: רשימה של נושאים המבטאת כמה מילה נמצאת בנושא וכמה לא.
פלט: האם ישנה תלות בין כל הנושאים לגבי המילה שהתקבלה.
פונקציות המחלקה:

public static double Chi(List<Statistic> s)
פונקציה סטטיסטית לחישוב האם המילה בעלת השפעה נושאים מסוימים או למילה אין כל קשר לנושאים מסוים. 

public static double ChiSquarePval(double x, int df)
פונקצית עזר לפונקציית ה Chi.

פונקציה סטטיסטית                                             private static double Exp(double x)
פונקציה סטטיסטית                                        private static double Gauss (double z)


מחלקות עזר עיקריות בפרויקט:
•	מחלקת FindNode:
תפקיד המחלקה: מחלקה המייצגת צומת בעץ הנושאים לצורך מציאת נושא למייל.

•	מחלקת EmailsData:
תפקיד המחלקה: מחלקה המחזיקה מילון בו עבור כל משתמש נשמרים הפרטים: כמות מיילים שקיבל עד כה וכמות.

•	מחלקת BinaryNode:
תפקיד המחלקה: מייצגת אובייקט מסוג צומת בעץ בינארי, מחלקה זו משמשת את מחלקת UpdateCommonWords  ליצירת העץ.



אלגוריתם
תיאור אלגוריתם מרכזי

מילון מושגים:
•	נושא- קטגוריה לרשימת מיילים העוסקים באותו תחום .
•	תת נושא/ נושא בן- חלוקת נושאים נוספת בתוך נושא, כל 'בן' של נושא נקרא תת נושא.
•	נושא אב- נושא שיש לו תת/תתי נושאים .
•	מילה לנושא- מילה שיש לה שייכות כל שהיא לנושא.
•	משקל מילה לנושא- מידת הקשר של המילה לנושא.
•	מילה משותפת- מילה שקשורה לנושא מסוים ולכל הצאצאים שמתחתיו.
•	מילת קישור- מילה המופיעה בנושאים רבים ואין לה כל השפעה במציאת נושא מסוים.
•	משפט קשור/עיקרי- מידע מתוך תוכן המייל שאותו המשתמש יכול לראות ללא פתיחת המייל.

תיאור התהליך המרכזי של המערכת:
המערכת פועלת באופן דינאמי, כך שכל משתמש יכול להתאים אותה לצרכים האישיים שלו. זאת על ידי שכל משתמש מגדיר נושאים (ותתי נושאים) בהתאם לתוכן המיילים שמקבל. 
המשתמש יכול בכל שלב להוסיף נושאים נוספים ולחילופין למחוק אותם.
המערכת הינה מערכת מתלמדת, המתבססת על מאגרי מילים על פיהם היא תנתח את תוכן המייל, מאגרי מילים אילו גדלים לאורך כל חיי המערכת, ככל שמספר המיילים יעלה יהיו למערכת יותר נתונים המאפשרים לה להגיע לתוצאות מיונים מדויקים יותר.

המערכת פועלת בשתי מישורים:
בתחילת השימוש אין למערכת מספיק נתונים על סיווגים מוצלחים שיסייעו לה לפענח את המייל. בשלב זה כשמגיע מייל חדש המערכת מנסה לסווג אותו כפי יכולתה אך תפקיד המשתמש הוא לעקוב אחרי התוצאות ובמידת הצורך גם לתקן את הנושא הנבחר כדי לשפר את האלגוריתם, המערכת מסיקה מסקנות אודות התיקונים, ולומדת על פיהם כיצד לסווג את
המיילים הבאים.
לדוג' עבור המייל הבא:
"התקבלה תרומה מאת פלוני אלמוני בסך 500 שקלים" הוחלט שהוא בנושא "תרומות"
כל מילות המייל (שלא נפלו בניקוי המייל ממילות קישור) נשמרות במאגר כמתארות את הנושא, לכל מילה ישמר משקל אשר מציין את הסבירות שמילה זו משפיעה במציאת הנושא, עבור כל מופע של המילה במייל מוסיפים לציון המילה 1.
לדוג' עבור המילה שקלים:
מילה	נושא 	משקל
שקלים	תרומות	1

בשלב הבא- שלב התפעול, המערכת נעזרת במילים ובמשקליהם כדי לסווג מיילים נוספים ולהחליט לאיזה נושא הם שייכים.
המערכת תהיה מסוגלת לסווג את המיילים בכוחות עצמה עפ"י הידע שרכשה קודם בשלב -הלמידה, ובמקרה שטעתה בהחלטתה גם כאן המשתמש יוכל להתערב ולשנות את הקטגוריה, בשלב זה היא ממשיכה להגדיל את מאגרי המידע ע"י כל סיווג וסיווג, כתוצאה מכך ככל שהמערכת תקבל יותר מיילים היא עתידה להגיע לתוצאות מדויקות יותר.
הדגשה:
שני השלבים המתוארים יקרו ויחזרו על עצמם בכל פעם שתוכנס למערכת קטגוריה חדשה.

מבנה נושאים לדוגמא:
על מנת להסביר את ניתוח האלגוריתם אני נעזרת במבנה הבא בעל 5 נושאים:

1. תרומות                 2. סיוע

                  3. מתנדבים        4. חולים 
                          
          5. משמרות         

האלגוריתם המרכזי:
האלגוריתם המרכזי הוא מציאת נושא המייל.
ומתווספים אליו כעין אלגוריתמים קטנים בפני עצמם:
•	מציאת משפט עיקרי לנושא
•	עדכון מילים משותפות
•	הוספת נושא 
•	מחיקת נושא
•	שינוי נושא למייל


מציאת נושא המייל
בתהליך מציאת הנושא של המייל הושקעה מחשבה וטרחה מרובה. המטרה היא להגיע לפתרון מדויק ככל האפשר- כלומר מציאת הנושא המתאים ביותר, לצורך זה יש להגיע לפתרון אופטימלי מבחינת אכיפה של מקרים היכולים להוות בלבול למערכת במציאת הנושא. 
מציאת נושא המייל מתבסס על:
1.	'מילות נושא'-
על פי סיווג המיילים לנושאים, שנעשה ב"תקופת –הלמידה", מתקבל עבור כל נושא מאגר של מילים המתארות את הנושא.
ההנחה היא: שככל שמספר המילים ששויכו בעבר לנושא מסוים, מופיעות יותר במייל
המועמד לפיענוח, כך הסיכוי שזהו הנושא המדובר במייל הנוכחי.
האלגוריתם עובר על המילים במייל החדש, בודק עבור כל מילה לאיזה נושא היא
משתייכת בדיקה זאת נעשית ע"פ המידע שנצבר בקריאת המיילים בעבר. 
עבור כל נושא מצטבר משקל כולל של מספר המילים השייכות לנושא והופיעו במייל החדש, נושא שמשקלו הוא הגדול ביותר כנראה שהוא הנושא בו עוסק המייל.

2.	איש הקשר'- (שולח המייל)
איש הקשר בדרך כלל נותנת אינדיקציה על נושא המייל ותוכנו.
האלגוריתם יוצא מנקודת הנחה שאיש קשר ששלח בפעמים הקודמות מספר רב של מיילים בנושא מסוים, קיים סיכוי גדול שגם הפעם המייל ששלח עוסק באותו נושא. לאחר "תקופת הלמידה" מתקבל מאגר שבו שויך כל איש קשר (שולח מייל) לנושאי המיילים שאותם שלח, כאשר משקלו של איש הקשר בנושא מסוים עולה עם כל שליחה נוספת של מייל באותו נושא. האלגוריתם צובר את מספר הפעמים שהגיע מייל מאיש הקשר עבור כל נושא, נושא שמשקלו הוא המקסימלי מחזק את ההנחה שהוא הנושא המדובר.

בכדי לחבר בין שני המאפיינים בעזרם האלגוריתם "מנחש" את נושא המייל חשבתי על הפתרון הבא:
פתרון א:
עבור כל נושא ניקח את משקלו (כתוצאה מאלגוריתם 'מילות נושא') ואת המשקל של איש הקשר ביחס לאותו נושא ונחשב 85% ממשקל של 'מילות הנושא' ו 15% ממשקל אנשי קשר.
נמצא את הנושא בעל הערך המקסימלי שחושב- והוא הנושא הנבחר.
חסרון: 
פתרון זה אינו מוצא את נושא המייל בדיוק מקסימלי- כי במצב בו המייל מכיל מילים השייכות 
לאב נושא ולתת נושא, כך שמילים של אב נושא גוברות במשקלן על מילות תת הנושא, אך מילות תת נושא אלו משמעותיות מאד המשייכות את המייל לתת הנושא ולא לאביו.
לדו' עבור המייל "אשמח אם תוכלו לדאוג לנו למכונת חמצן"
במאגר היו הנתונים הבאים:
מילה	משקל	נושא	נושא אב
לדאוג	50	סיוע	-
מכונת חמצן	25	חולים	סיוע

במצב כזה יבחר הנושא "סיוע" משום שהוא בעל הציון הגבוה ביותר, למרות שהמילה "מכונת חמצן" משמעותית ביותר עבור הנושא "חולים" ולמעשה מייל זה משתייך לקטגורית "סיוע לחולים"- כלומר לנושא "חולים" שהוא תת נושא של "סיוע".

מצב זה הוביל אותי לנקודת הנחה כי המילים המתארות אב מתארות גם את התתי נושאים שתחתיו.

פתרון ב:
על כן החלטתי שלאחר מציאת משקלי הנושאים, להוסיף לכל תת נושא את סכום משקלי אבותיו, ורק לאחר מכן להחליט לאיזה נושא שייך המייל.
לדו' עבור המייל "נשמח אם תוכלו לדאוג לנו למכונת חמצן"
במאגר היו הנתונים הבאים:
מילה	משקל	נושא	נושא אב
לדאוג	50	סיוע	-
מכונת חמצן	25	חולים	סיוע

לכל נושא מצרפים את משקלי כל האבות הקדמונים שלו:
סיוע = 50
חולים = 50 + 25 = 75
על כן מייל זה משתייך לנושא "חולים".
חסרון :
אף פתרון זה אינו אפשרי מכיוון שהוא גורם שהמייל ישויך ישירות לבן במקום לאב, 
זאת משתי סיבות:
א. כיוון שברגע שמופיעה במייל מילה אחת, ולו הפחותה ביותר מבחינת משמעות עם משקל נמוך מאד שקשורה לנושא הבן- המייל יסווג לנושא הבן ישירות (כיון שצירפנו את משקלי
האב לבן(.
ב. למצב בו המייל יסווג ישירות לבן ניתן להגיע גם מכיוון נוסף: כאשר במאגר הנתונים של
המילים המתארים את נושא המייל קיימת מילה אשר מתארת גם את נושא האב וגם את נושא הבן.
נ.ב: מצב שבו מילה מתארת גם את נושא האב וגם את נושא הבן יכול להתקבל לאחר החלטת נושא המייל שאז נשפכות כל מילות המייל לטבלת 'מציאת נושא' לצורך הגדלת מאגרי הנתונים -מאגר 'מילות נושא'.
ואז במקרה כזה המייל ישויך ישירות לבן.
לדו' עבור המייל "נודה מאוד אם תעזרו לנו בארגון המשלוח"
מילה	משקל	נושא	נושא אב
תעזרו	35	סיוע	-
תעזרו	20	מתנדבים	סיוע
תעזרו	15	חולים	סיוע

סיוע = 35
מתנדבים = 20 + 35 = 55
חולים = 15 + 35 = 50
המייל ישויך בטעות לנושא "מתנדבים" למרות שהמייל משתייך ל"סיוע" כללי.

ולכן אני מגיעה למסקנה שצריך ליצור מצב שבו לא תהיה מילה זהה המתארת נושא אב וגם נושא בן.

פתרון ג:
אני מנסה להגיע למצב שבו לא תהיה את אותה מילה לאב נושא ולבן:
1.	כאשר הוחלט על נושא כלשהוא למייל, אם הנושא הוא תת נושא(כלומר יש לו אבא)- לא נוסיף ישר את המילים שבמייל כמילים שמתארות את התת נושא, אלא נבדוק האם המילה קיימת באחד מאבותיו, ואם היא קיימת- היא לא תתווסף כ'מילת נושא' לבן אלא רק יתווסף משקל לאב.
בעיה: 
לאחר מחשבה עולה כי א"א להתבסס על העיקרון שמילה הנמצאת באב לא תתווסף לבן, נצא מנקודת הנחה שקיימות מילים השייכות לתת נושא שלא הגיעו בשלב ההתלמדות, וברצוננו להוסיף אותם למאגר המילים תוך כדי התלמדות המערכת, ובהגיע מייל ובו מילה חדשה השייכת לתת הנושא ומילה נוספת המתארת נושא אב שנמצאת כבר במאגר, לכאורה המייל יסווג לנושא אב שזה בסדר גמור בשלב זה, אך המילה החדשה אוטומטית תשמר במאגר כמילת נושא -לנושא האב (בעקבות הוספת כל מילות המייל כ'מילות נושא' המתארות את הנושא הנבחר), כך שבמשך כל שנות המערכת המילה החדשה לא תתוסף לתת נושא הבן, גם אם יגיעו מלוני מיילים נוספים עבור תת הנושא המכילים את אותה מילה,  מילה זו לא תשתייך אליו כלל מאחר שכבר הופיע באביו עוד קודם והיא תייצג את האב לתמיד.

2.	אחת לכמה זמן תתבצע פונקציה באופן אוטומטי שתבדוק האם המילה המתארת נושא אב מתארת גם את בניו, ועל כן המילה תיוצג כמילה משותפת לאותו נושא ולכל צאצאיו.
בעיה:
אם ה'מילת נושא' לא נמצאה כמילה משותפת- שמתארת אב ותתי נושאים והיא לא הועלתה לייצג את האב- חוזרים למצב בו קימת אותה 'מילת נושא' לאב ולבן שזאת הבעיה מקורית שתוארה לעיל.
אם ה'מילת נושא' עלתה לתאר את נושא האב, יתכן ותחזור שוב להשתייך לתת הנושא ונחזור שוב לבעיה הנ"ל וחוזר חלילה.
יתכן שניתן לשמור בדרך כלשהי במסד נתונים כי המילה הועלתה לתאר את נושא האב, וכל פעם לפני עדכון כל מילות המייל כ'מילות נושא' לנושא הנבחר תתבצע בדיקה האם המילה 'הועלתה' או שנמצאת אצל האב ללא קשר לבניו אבל תהליך זה יהיה מורכב ומסובך מבחינת סיבוכיות מקום וסיבוכיות זמן.

הפתרון הנבחר
לאור כל הנ"ל ולאחר חשיבה מעמיקה, הגעתי למסקנה כי עלי לחלק את המילים בעבור כל
נושא לשני חלקים:
1.	מילים משותפות- מילים המתארות את הנושא וכן את בניו.
2.	מילים מיוחדות- מילים המתארות נושא מסוים ללא בניו.








מילים משותפות מהוות אינדיקציה לאיזה אב נושא המייל שייך, לכן אופן החישוב נעשה בשלב ראשוני ע"י זיהוי נושא אב ורק לאחר מכן מציאת הנושא הספציפי תחתיו.
כדי לזהות את נושא המייל האלגוריתם יבצע מספר חישובים,
1.	תחילה נזהה תחת איזה תת עץ נמצא הנושא, זאת ע"י חישוב לכל נושא את סכום משקל מילים מיוחדות +מילים משותפות 
2.	לאחר זיהוי תת עץ אליו משויך הנושא נשווה בין המילים המיוחדות של הנושא המקסימאלי לבין כל בניו של נושא זה שוב ע"י חישוב לכל בן את סך מילים משותפות+ מילים מיוחדות. 
3.	במצב בו אחד הבנים גובר על נושא האב, תמשיך אותה הרוטינה לבדוק את מילים מיוחדות של הבן לעומת הבנים שלו (כך שלהם מתבצע החישוב מיוחד+ משותף( כלומר חוזרים שוב לשלב מס' 2 אך כעת ראש תת העץ הוא הבן המקסימלי.
4.	ובמצב בו המילים המיוחדות של הנושא המקסימלי גוברות על חישוב של משקלי בניו, או במצב בו אין לנושא המקסימלי בנים החישוב נעצר ,ונושא זה יוגדר כנושא המייל.

תרשים זיהוי בעבור המייל הבא:
"נשמח אם תעזרו לנו ותשלחו בחור חרוץ שיטפל בקשיש"

המילה	משותפת?	משקל	נושא
תעזרו	כן	30	סיוע
תעזרו		15	תרומות
בחור	כן	20	מתנדבים
קשיש		5	מתנדבים
קשיש		22	חולים

מציאת תת העץ המקסימלי:
תרומות	סיוע	חולים	מתנדבים	משמרות
מיוחד+משותף
15 + 0 = 15	מיוחד+משותף
0 + 30 = 30	מיוחד+משותף
22 + 0 = 22	מיוחד+משותף
5 + 20 = 25	מיוחד+משותף
0 + 0 = 0

האלגוריתם לא מסתיים, מקטינים את המילון ובו יופיעו הנושא "סיוע" ובניו. נשווה בין המילים המיוחדות של "סיוע" לבין שאר בניו (מיוחד+משותף):


סיוע	חולים	מתנדבים
מיוחד
0 = 0	מיוחד+משותף
22 + 0 = 22	מיוחד+משותף
5 + 20 = 25




הנושא המקסימלי הוא מתנדבים, אך גם כאן לא נעצרים שוב נשווה את המילים המיוחדות של האב למול המילים המיוחדות + המשותפות של הבנים:
מתנדבים	משמרות
מיוחד
5 + 0 = 5	מיוחד+משותף
0 + 0 = 0





נשים לב שהנושא המירבי הוא מתנדבים, שמשקלו גובר על משקלי בניו ולכן הוא הנושא הנבחר.

אנשי קשר במציאת הנושא:
כאמור לעיל, מציאת הנושא מתבססת על שני מאפיינים- מילות נושא וכן איש קשר.
כמובן שמילות נושא יש להן משמעות רבה לעומת אנשי קשר לפיכך אחוז ההשפעה שלהם
במציאת הנושא יהיה גבוה יותר לעומת אחוז ההשפעה של אנשי הקשר.
לכן בשלב בו אני סוכמים לכל נושא את משקל המילים, נציין בעבור כל נושא כמה מיילים שלח איש בקשר לאותו נושא. בכדי להחליט לאיזה נושא שייך המייל, בעבור כל נושא ניקח 15% ממשקל כמות המיילים ששלח לאותו נושא, וכן 85% ממשקל מילות הנושא כפי שתואר לעיל, הנושא בעל החישוב המקסימלי הוא זה שנקבע להיות נושא המייל.
שם   -   נושא     

   85%        15%
  מילים     איש קשר

אתגרים באלגוריתם מציאת נושא

אתגר ראשון:
כבר בשלב החשיבה על האלגוריתם שמתי לב לאתגר שיש בשפה העברית, כמעט כל מילה משתנה בהתאם לזמן (עבר, הווה ועתיד), בהתאם לגוף ,למיקום במשפט, הוספת אותיות מש"ה וכל"ב ויחיד ורבים, מה שגורם לאלגוריתם להגיע לתוצאות לא מדויקות ולמלא מידע בשביל לצבור את כל הטיות המילים.
משום שאם למערכת יש מידע עבור המילה "הליכה" ששייכת לדו' לנושא "ספורט",
במקרה ויגיע אליה מייל נוסף עם המילה – להליכה / הליכות / הלכו / ללכת וכו' היא לא תקשר את המילה ההיא למילה "הליכה" שאותה היא מכירה.
ובנוסף יש עוד בעיה- של עומס נתונים במערכת, משום שהמערכת תשמור אצלה עבור מילה אחת- מלא הגיות וצורות הטיה שאלו למעשה מילים כפולות שחוזרות על עצמן.
ולכן הגעתי למסקנה שעבור כל שורש בשפה אני רוצה לשמור במערכת מילה אחת בלבד שהיא תייצג לי את כל המילים שבשורש שלה, חיפשתי ספריה שעושה זאת ומצאתי את ספרית Hebrew Nlp אשר מספקת ניתוח לכל מילה- מידע על אופייה.
 היכולות העיקריות של הספרייה:
•	ניתוח מורפולוגי: 
המנוע המתקדם לא רק מנרמל את המילים אלא גם מציין את חלקי הדיבור שלהם (שם עצם, פועל, שייכות וכ"ו )

